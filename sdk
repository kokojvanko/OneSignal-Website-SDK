#! /usr/bin/env node

const yargonaut = require('yargonaut')
                          .style('blue', 'required')
                          .errorsStyle('red.bold')
                          .helpStyle('green')
const yargs = require('yargs');
const chalk = require('chalk');
const nconf = require('nconf');
const json5 = require('json5');
const spawn = require('child_process').spawn;
const fs = require('fs-extra');


const argv = yargs
  .usage('★ OneSignal Web SDK Build Tool ★')
  .help('help').alias('help', 'h')
  .wrap(120)
  .option('env', {
    alias: 'e',
    choices: ['development', 'staging', 'production'],
    description: `The target environment for this build.`,
    requiresArg: true,
    type: 'string',
    required: true,
    default: 'development',
    global: true,
  })
  .option('config', {
    alias: 'c',
    description: `Path to config.json file.`,
    requiresArg: true,
    required: true,
    default: './config.json',
    global: true
  })
  .command({
    command: 'build',
    aliases: 'b',
    desc: `Builds the web SDK.  
           Optionally add '--tests' to build with tests.`,
    handler: onBuild
  })
  .example('./sdk build --tests', 'Build the web SDK for development (default) with tests.')
  .example('./sdk build --env prod', 'Build the web SDK for production.')
  .strict()
  .demand(1)
  .argv;

function printEnvironment(config) {
  let env = config.get('env')
  let color = chalk.white.bgBlue;
  if (env === 'staging') {
    color = chalk.white.bgMagenta;
  }
  else if (env === 'production') {
    color = chalk.white.bgRed;
  }
  console.log(`${chalk.blue('Environment:')} ${color(env.toUpperCase())}`)
  console.log(`${chalk.blue('Current Working Directory:')} ${process.cwd()}`)
  console.log();
}

function onBuild(argv) {
  var config = nconf.env()
                    .file({ file: argv.config, format: json5 });
  config.set('env', argv.env);
  console.log('OneSignal Web SDK Build Tool');
  console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━')
  printEnvironment(config);
  return clean(config)
         .then(() => transpileTypescript(config))
         .then(() => runModuleBundler(config))
         .catch(e => console.error(chalk.red(`Fatal build error: ${e}`)));
}

function clean(config) {
  return new Promise((resolve, reject) => {
    const rmDir = spawn('rm', ['-r', config.get('build:tempDirectory')]);
    rmDir.stdout.on('data', data => {
      console.log(`${chalk.blue('[Clean]')} ${data.toString()}`);
    });
    rmDir.stderr.on('data', function (data) {
      console.error(chalk.red(`${chalk.blue('[Clean]')} ${data.toString()}`));
    });
    rmDir.on('exit', function (code) {
      if (code !== 0) {
        reject(chalk.red(`${chalk.blue('[Clean]')} 'rm' exited with code ${code}`));
      } else {
        resolve();
      }
    });
  });
}

/**
 * Transpiles source TypeScript files to individual JavaScript files based on passed tsconfig.json.
 *
 * Watches for changes to source TypeScript files (even over VMWare network file system!).
 */
function transpileTypescript(config) {
  return new Promise((resolve, reject) => {
    const transpiler = spawn('tsc', ['--project', 'tsconfig.es5.json', '--watch']);
    transpiler.stdout.on('data', data => {
      const message = data.toString();
      console.log(`${chalk.blue('[TypeScript Transpiler]')} ${message}`);
      if (message.includes('Compilation complete.')) {
        resolve();
      }
    });
    transpiler.stderr.on('data', function (data) {
      console.error(chalk.red(`${chalk.blue('[TypeScript Transpiler]')} ${data.toString()}`));
    });
    transpiler.on('exit', function (code) {
      if (code !== 0) {
        reject(chalk.red(`${chalk.blue('[TypeScript Transpiler]')} 'tsc' exited with code ${code}`));
      } else {
        resolve();
      }
    });
  });
}

/**
 * Watches for changes to TypeScript transpiler's generated JavaScript files, and bundles all JavaScript files
 * together into one bundle. Pipeline transformations are as follows:
 *
 * 1. Bundle JS files into one module.
 * 2. Bundle SCSS files into one CSS file.
 * 3. Replaces $_VAR preprocessor variables for things like $_VERSION and $_DEV.
 * 4. Minifies the CSS using clean-css.
 * 5. Minifies the JavaScript using UglifyJS.
 * 6. Transforms multi-level source map back to original source map using Sorcery.
 * 7. Copies output files to target output directory.
 *
 * These transformations are controlled by the brunch-config.js file.
 */
function runModuleBundler(config) {
  return new Promise((resolve, reject) => {
    const bundler = spawn('brunch', ['watch']);
    bundler.stdout.on('data', data => {
      const message = data.toString();
      console.log(`${chalk.blue('[Module Bundler]')} ${message}`);
      if (message.includes('info: compiled')) {
        transformSourceMaps();
      }
    });
    bundler.stderr.on('data', function (data) {
      console.error(chalk.red(`${chalk.blue('[Module Bundler]')} ${data.toString()}`));
    });
    bundler.on('exit', function (code) {
      if (code !== 0) {
        reject(chalk.red(`${chalk.blue('[Module Bundler]')} 'brunch' exited with code ${code}`));
      } else {
        resolve();
      }
    });
  });
}

/**
 * 6. Transforms multi-level source map back to original source map using Sorcery.
 *
 * For some reason, Sorcery requires the file and map to be at the project root.
 *
 * Copy src/map to root -> Apply Sorcery -> Copy files to build/bundler-sourcemapped/ -> Remove copies
 */
function transformSourceMaps() {
  fs.move('/build/bundler')
}