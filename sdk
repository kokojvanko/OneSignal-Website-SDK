#! /usr/bin/env node

const yargonaut = require('yargonaut')
                          .style('blue', 'required')
                          .errorsStyle('red.bold')
                          .helpStyle('green')
const yargs = require('yargs');
const chalk = require('chalk');
const nconf = require('nconf');
const json5 = require('json5');
const spawn = require('child_process').spawn;
const fs = require('fs-extra');
const path = require('path');


const argv = yargs
  .usage('★ OneSignal Web SDK Build Tool ★')
  .help('help').alias('help', 'h')
  .wrap(120)
  .option('env', {
    alias: 'e',
    choices: ['development', 'staging', 'production'],
    description: `The target environment for this build.`,
    requiresArg: true,
    type: 'string',
    required: true,
    default: 'development',
    global: true,
  })
  .option('config', {
    alias: 'c',
    description: `Path to config.json file.`,
    requiresArg: true,
    required: true,
    default: './config.json',
    global: true
  })
  .command({
    command: 'build',
    aliases: 'b',
    desc: `Builds the web SDK.  
           Optionally add '--tests' to build with tests.`,
    handler: onBuild
  })
  .example('./sdk build --tests', 'Build the web SDK for development (default) with tests.')
  .example('./sdk build --env prod', 'Build the web SDK for production.')
  .strict()
  .demand(1)
  .argv;

function printEnvironment(config) {
  let env = config.get('env')
  let color = chalk.white.bgBlue;
  if (env === 'staging') {
    color = chalk.white.bgMagenta;
  }
  else if (env === 'production') {
    color = chalk.white.bgRed;
  }
  console.log(`${chalk.blue('Environment:')} ${color(env.toUpperCase())}`)
  console.log(`${chalk.blue('Current Working Directory:')} ${process.cwd()}`)
  console.log();
}

function onBuild(argv) {
  var config = nconf.env()
                    .file({ file: argv.config, format: json5 });
  config.set('env', argv.env);
  console.log('OneSignal Web SDK Build Tool');
  console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━')
  printEnvironment(config);
  return clean(config)
         .then(() => transpileTypescript(config))
         .then(() => runModuleBundler(config))
         .catch(e => console.error(chalk.red(`Fatal build error: ${e}`)));
}

function clean(config) {
  return new Promise((resolve, reject) => {
    const rmDir = spawn('rm', [
      '--recursive',
      '--preserve-root',
      '--force',
      config.get('build:tempDirectory')
    ]);
    rmDir.stdout.on('data', data => {
      console.log(`${chalk.blue('[Clean]')} ${data.toString()}`);
    });
    rmDir.stderr.on('data', function (data) {
      console.error(chalk.red(`${chalk.blue('[Clean]')} ${data.toString()}`));
    });
    rmDir.on('exit', function (code) {
      if (code !== 0) {
        reject(chalk.red(`${chalk.blue('[Clean]')} 'rm' exited with code ${code}`));
      } else {
        resolve();
      }
    });
  });
}

/**
 * Transpiles source TypeScript files to individual JavaScript files based on passed tsconfig.json.
 *
 * Watches for changes to source TypeScript files (even over VMWare network file system!).
 */
function transpileTypescript(config) {
  return new Promise((resolve, reject) => {
    const transpiler = spawn('tsc', [
      '--project',
      'tsconfig.es5.json',
      '--watch',
      '--outDir',
      config.get("build:typescriptOutDir")
    ]);
    transpiler.stdout.on('data', data => {
      const message = data.toString();
      console.log(`${chalk.blue('[TypeScript Transpiler]')} ${message}`);
      if (message.includes('Compilation complete.')) {
        resolve();
      }
    });
    transpiler.stderr.on('data', function (data) {
      console.error(chalk.red(`${chalk.blue('[TypeScript Transpiler]')} ${data.toString()}`));
    });
    transpiler.on('exit', function (code) {
      if (code !== 0) {
        reject(chalk.red(`${chalk.blue('[TypeScript Transpiler]')} 'tsc' exited with code ${code}`));
      } else {
        resolve();
      }
    });
  });
}

/**
 * Watches for changes to TypeScript transpiler's generated JavaScript files, and bundles all JavaScript files
 * together into one bundle. Pipeline transformations are as follows:
 *
 * 1. Bundle JS files into one module.
 * 2. Bundle SCSS files into one CSS file.
 * 3. Replaces $_VAR preprocessor variables for things like $_VERSION and $_DEV.
 * 4. Minifies the CSS using clean-css.
 * 5. Minifies the JavaScript using UglifyJS.
 * 6. Transforms multi-level source map back to original source map using Sorcery.
 * 7. Copies output files to target output directory.
 *
 * These transformations are controlled by the brunch-config.js file.
 */
function runModuleBundler(config) {
  const env = config.get('env');
  return new Promise((resolve, reject) => {
    const enableIgnoredMessagesPattern = true;
    const ignoredMessagePatterns = [
      /config.overrides.*perhaps you meant/,
      ///The correct use of entry points is/,
      /compiled, but not written. Check/
    ];
    const bundler = spawn('brunch', [
      'watch',
      '--env',
      env,
      '--jobs',
      '3',
    ], {
      env: Object.assign(Object.create(process.env), {
        bundlerOutDir: config.get('build:bundlerOutDir'),
        typescriptOutDir: config.get('build:typescriptOutDir')
      })
    });
    bundler.stdout.on('data', data => {
      const message = data.toString();
      console.log(`${chalk.blue('[Module Bundler]')} ${message}`);
      if (message.includes('info: compiled')) {
        transformSourceMaps(config)
        distributeReleaseFiles(config);
      }
    });
    bundler.stderr.on('data', function (data) {
      const message = data.toString();
      if (enableIgnoredMessagesPattern) {
        for (const ignoredMessagePattern of ignoredMessagePatterns) {
          if (message.match(ignoredMessagePattern))
            return;
        }
      }
      console.error(chalk.red(`${chalk.blue('[Module Bundler]')} ${message}`));
    });
    bundler.on('exit', function (code) {
      if (code !== 0) {
        reject(chalk.red(`${chalk.blue('[Module Bundler]')} 'brunch' exited with code ${code}`));
      } else {
        resolve();
      }
    });
  });
}

/**
 * 6. Transforms multi-level source map back to original source map using Sorcery.
 *
 * For some reason, Sorcery requires the file and map to be at the project root.
 *
 * Copy src/map to root -> Apply Sorcery -> Copy files to build/bundler-sourcemapped/ -> Remove copies
 */
function transformSourceMaps(config) {
  try {
    const bundlerOutDir = config.get('build:bundlerOutDir');
    const bundledFilenames = fs.walkSync(path.resolve(bundlerOutDir))
                               .map(file => file.slice(file.lastIndexOf('/') + 1));
    fs.copySync(bundlerOutDir, './');

    var transformPromises = [];
    bundledFilenames.map(filename => {
      if (!filename.endsWith('.js'))
        return;

      transformPromises.push(
        new Promise((resolve, reject) => {
          var sorcerer = spawn('sorcery', [
            '--input',
            filename,
          ]);
          sorcerer.stdout.on('data', data => {
            const message = data.toString();
            console.log(`${chalk.blue('[Transform Source Maps]')} ${message}`);
          });
          sorcerer.stderr.on('data', function (data) {
            console.error(chalk.red(`${chalk.blue('[Transform Source Maps]')} ${data.toString()}`));
          });
          sorcerer.on('exit', function (code) {
            if (code !== 0) {
              reject(chalk.red(`${chalk.blue('[Transform Source Maps]')} 'sorcery' exited with code ${code}`));
            } else {
              console.log(`${chalk.blue('[Transform Source Maps]')} Transformed source map for ${chalk.blue(filename)}`);
              fs.copySync(filename + '.map', `${bundlerOutDir}/${filename + '.map'}`);
              fs.removeSync(filename);
              fs.removeSync(filename + '.map');
              resolve();
            }
          });
        }));
    });

    return Promise.all(transformPromises);
  } catch (e) {
    console.error(`${chalk.blue('[Transform Source Maps]')} ${chalk.red(e)}`);
  }
}

function distributeReleaseFiles() {

}